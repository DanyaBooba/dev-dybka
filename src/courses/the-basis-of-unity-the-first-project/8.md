---
prev: "7"
next: "9"
title: "8. Работаем над логикой игры | Курс"
---

# 8. Работаем над логикой игры

В этом уроке мы поработаем над логикой игры. Перейдем к программированию на C#. Создадим несколько игровых скриптов, которые будут описывать логику работы игры.

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMovable : MonoBehaviour
{
    [SerializeField] private Transform groundPoint;
    [SerializeField] private LayerMask groundLayer;

    private Rigidbody2D rb;

    private float speed = 7f;
    private float jumpForce = 5f;

    private float moveInput;
    private float flipValue;
}
```

## Создадим поля в «PlayerMovable»

`[SerializeField] private`

Данный блок кода отвечает за возможность добавить ссылку на поле в Инспекторе. Отличия от модификатора доступа «public» в том, что модификатор доступа разрешает доступ к полю из других скриптов и доступ из Инспектора, а SerializeField разрешает только доступ из Инспектора.

Разберем каждое поле отдельно:

- groundPoint: это точка, которая будет отвечать за касание с землей.
- groundLayer: это слой, который будет отвечать за «землю».
- rb: ссылка на физику объекта.
- speed: задаем скорость игрока.
- jumpForce: задаем силу прыжка.
- moveInput: ссылка на направление движения.
- flipValue: параметр, отвечающий за поворот игрока.

## Добавляем методы в скрипт

Теперь нам требуется добавить методы в скрипт.

```C#
private void Start()
{
    rb = GetComponent<Rigidbody2D>();
}

private void FixedUpdate()
{
    moveInput = Input.GetAxis("Horizontal");
    rb.velocity = new Vector2(moveInput * speed, rb.velocity.y);

    if(moveInput != 0) flipValue = FlipValue(moveInput);
    transform.eulerAngles = VectorFlip(flipValue);
}

private void Update()
{
    if (Input.GetKeyDown(KeyCode.Space)) Jump();
}

private void Jump()
{
    if(extraJump > 0) rb.velocity = Vector2.up * jumpForce;
}

private Vector3 VectorFlip(float count)
{
    Vector3 vector = new Vector3(0, count, 0);
    return vector;
}

private float FlipValue(float count)
{
    if (count > 0) return 180;
    return 0;
}

private Collider2D Ground()
{
    return Physics2D.OverlapCircle(groundPoint.position, 0.25f, groundLayer);
}
```

Разберем добавленные в скрипт методы:

- Start(): данный метод выполяется один раз при инициализации игры.
- FixedUpdate(): выполняется каждую секунду 50 раз.
- Update(): выполняется то количество раз, сколько FPS в игре.
- Jump(): метод, выполняющий прыжок в игре.
- VectorFlip(): вспомогательный метод для поворота игрока.
- FlipValue(): вспомогательный метод для поворота игрока.
- Ground(): метод, возвращающий параметр bool, было ли касание в игре или нет.

> FPS — количество сменяемых кадров за единицу времени.

Метод может возвращать определенный параметр. Для этого следует использовать следующую конструкцию:

```C#
private <типданных> Ground()
{
    return <условие>
}
```

Вместо ключевого слова «void» следует использовать тот тип данных, который будет возвращаться методом. А для возврата используйте ключевое слово «return». После «return» указывается параметр, который будет возвращаться.

## Подробнее про методы скрипта

В методе Start() мы обращаемся к физике объекта. Это нужно для того, чтобы в нашем поле «rb» хранилась ссылка на физику игрока.

В методе FixedUpdate() хранится логика для перемещения.

`moveInput = Input.GetAxis("Horizontal");`

Получаем информацию о вводе по горизонтали. Если говорить иначе: это информация о вводе кнопок «A» и «D» на компьютере. Если мы вводим «A», параметр изменяет значение от «0» до «-1». Если «D» — то от «0» до «1».

`rb.velocity = new Vector2(moveInput \* speed, rb.velocity.y);`

Данное поле отвечает за вектор скорости. Для передвижения мы изменяем поле по оси «X», поэтому задаем ему значение: «moveInput \* speed».

`if(moveInput != 0) flipValue = FlipValue(moveInput);`

Здесь, если мы двигаемся: «if(moveInput != 0)», то совершаем поворот игрока.

`transform.eulerAngles = VectorFlip(flipValue);`

Здесь мы задаем поворот игрока.

Разберем конструкцию условий. В программировании у нас есть возможность задавать условия. Внутри условия проверяется поле типа bool, которое принимает значение «true» или «false».

По умолчанию конструкция условий выглядит следующим образом:

```C#
if(<условие>)
{
    <правда>
}
else
{
    <ложь>
}
```

После ключевого слова «if» стоит условие. Условие может быть представлено совокупностью условий или одним параметром bool.

После условия стоит блок: «правда». Данный блок выполнится в том случае, если условие является правдой. К примеру, «5 >= 3» является правдой. Но вот уже условие «3 > 5» не является правдой, поэтому выполнится условие «ложь».

Условия проверки задаются следующими конструкциями:

- «A == B»: A равно B
- «A > B»: A больше B
- «A < B»: A меньше B
- «A >= B»: A больше или равно B
- «A <= B»: A меньше или равно B
- «A != B»: A не равно B

В разных языках программирования используются немного разные конструкции для того, чтобы сравнивать поля. Данный пример рассмотрен в случае для языка программирования C#.

Помимо «if» и «else» еще существует конструкция «else if», в которую можно задать условие, если блок «if» не выполнится. Вот пример кода:

```C#
if(A > B) {
    // A больше B
}
else if(A == B) {
    // A равно B
}
else {
    // A меньше B
}
```

## Добавляем скрипт на игрока

Переходим к игровому движку. Выбираем нашего игрока в поле Иерархии. Справа в инспекторе внизу выбираем поле «Add Component» и пишем название нашего скрипта: «PlayerMovable».

После добавления скрипта он отобразится справа в Инспекторе. Теперь нам требуется добавить точку для касания с землей и слой, отвечающий за землю.

## Добавляем точку для касания с землей

Выбираем нашего игрока. Делаем правый клик мыши внутри поля Иерархии. Выбираем: «Create Empty». Даем название объекту: «groundPoint». Перетягиваем объект ближе к низу нашего игрока. И получаем такой результат:

![Игровое пространство Unity](../data/less8/less8__01.jpg)

Теперь перейдем к созданию слоя, который будет отвечать за «землю» в игре.

Выберем платформу слева. Перейдем к Инспектору. Вверху выберем поле «Layer». Выберем данное поле и нажмем на «Add Layer». Далее, в поле Инспектора у нас появится возможность добавить новый слой. Выбираем любое пустое поле и даем ему название «Ground».

После чего заново выбираем нашу платформу и выбираем для нее наш новый слой «Ground».

## Добавляем объекты в скрипт игрока

Переходим к объекту игрока. У скрипта «PlayerMovable» есть 2 поля: Ground Point и Ground Layer. В первое поле нужно перетащить наш объект «groundPoint». Для этого мы можем выбрать объект «groundPoint» у игрока и перетащить в данное поле.

Для выбора второго поля мы должны поменять поле «Nothing» на «Ground».

## Запускаем игру

Можем перейти к запуску игры и попробовать поиграть в нее. Теперь у нас есть возможность перемещаться по платформе. Столкнуть врага с платформы.

## Скрипт для жизней

Добавим еще 2 скрипта: «PlayerHealth», «PlayerTouch». Первый скрипт будет отвечать за здоровье игрока. А скрипт «PlayerTouch» будет отвечать за обработку касаний игрока с объектами.

Сразу добавим 2 этих скрипта на игрока. Перейдем к написанию «PlayerHealth».

```C#
using UnityEngine.SceneManagement;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerHealth : MonoBehaviour
{
    private float maxHealth = 10f;
    private float health;

    private void Start()
    {
        health = maxHealth;
        Health();
    }

    private void Health()
    {
        if(health <= 0f) InvokeNullHealth();

        if(health > maxHealth) health = maxHealth;

        Debug.Log("Health: " + health);
    }

    public void Damage(float damage)
    {
        ChangeHealth(-damage);
    }

    private void ChangeHealth(float change)
    {
        health += change;
        Health();
    }

    private void InvokeNullHealth()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
    }

}
```

## Разберем данный скрипт подробнее.

В начале мы подключаем библиотеку «using UnityEngine.SceneManagement;». Данная библиотека даст нам возможность работать со сценами: загружать их, перезагружать страницу и прочее.

Далее мы используем 2 поля: `health` и `maxHealth`. Первое поле отвечает за текущее значение жизней. Второе поле отвечает за максимальное количество жизней.

Далее, методы скрипта. В методе `Start()` мы задаем жизням максимальное значение жизней. Следующая строка — вызов метода `Health()`. Данный метод проверяет следующие условия: жизней меньше или равно 0 — вызываем метод `InvokeNullHealth()`, жизней больше чем максимальное количество — присваиваем жизням максимальное количество жизней, чтобы не выйти за лимит максимального количества жизней. И в остальных случаях мы выводим на экран количество жизней: «Debug.Log("Health: " + health);».

Еще в данном классе описано 3 метода: Damage(float damage), ChangeHealth(float change) и InvokeNullHealth().

Первый метод принимает параметр в круглых скобках. Данный параметр отвечает за количество получаемого урона. Важно: значение указывается по модулю.

Метод Damage(float damage) вызывает метод ChangeHealth(float change) и передает ему параметр damage с отрицательным значением.

Метод ChangeHealth(float change) изменяет количество жизней и вызывает метод Health() для проверки условий с жизнями.

Оставшийся метод — InvokeNullHealth(). Данный метод вызывается, когда количество жизней становится меньше или равно нулю. Данный метод перезагружает сцену с помощью конструкции: «SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);».

## Обработка касания

Переходим к написанию скрипта, который будет отвечать за обработку касания игрока.

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerTouch : MonoBehaviour
{
    private PlayerHealth health;
    private float damage = 1f;

    private void Start()
    {
        health = GetComponent<Health>();
    }

    private void OnCollisionEnter2D(Collision2D collision)
    {
        Debug.Log(collision.gameObject.tag);
    }
}
```

Разберем данный скрипт подробнее.

В первой строке мы подключаем класс с обработкой жизней, а в методе Start() мы указываем ссылку на объект.

Также в данном скрипте обработки касания указан параметр «damage». При столкновении с врагом мы будем получать урон, равный значению «damage».

Дальше у нас указана конструкция для обработки касаний. Она называется «OnCollisionEnter2D». Данный метод обрабатывает касания с объектами, у которых имеются физические границы. Спойлер: наш объект может иметь границы, которые обычно называются «триггерами».

Сейчас мы в консоль выводим информацию о теге объекта. При запуске игры при любом касании мы будем получать вывод в консоль: «Untagged».
